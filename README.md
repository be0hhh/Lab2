
## Отчет по лабораторной работе №2

#### № группы: `ПМ-2402`

#### Выполнил: `Грашин Илья Романович`

#### Вариант: `7`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм и математическая модель](#4-алгоритм-и-математическая-модель)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

 Напишите программу на Java, которая выполняет следующие действия с
 двумерным массивом символов (строчные и заглавные буквы латинского
 алфавита):
 1. Считывает с консоли размер массива N , затем элементы массива
 размером N×N.
 2. Сортирует столбцы массива в порядке возрастания количества гласных букв в каждом столбце.
 При этом внутри столбца символы остаются на своих местах.
 Если показатели равны, сортирует столбцы по сумме ASCII-кодов символов.
 3. Находит и выводит символ, который чаще всего встречается в массиве (без учёта регистра).
 Если таких символов несколько, выводит
 все.
 4. Выводит элементы массива в виде спирали,
 начиная с центрального элемента и двигаясь против часовой стрелки.
 Реализовать алгоритм без использования дополнительных массивов.
 5. Шифрует массив, изменяя регистр букв на противоположный, вы
 водит зашифрованный массив


### 2. Входные и выходные данные

  1. На вход подается размер массива (N), после этого вводится NxN элементов в виде квадрата.
  2. Программа анализираует весь массив символов и определяет гласные буквы, после этого сортирует построчно массив, передвигая гласные буквы в конец, а после этого так же каждую строку сортирует по ASCII - кодам.
  3. Опять анализирует массив и находит самый частый символ (без учета регистра) и выводит его, если таких символов несколько, то выводит их в алфавитном порядке.
  4. Использует исходный массив, находит цетральный элемент, и, начиная с него, выводит массив в строку, используя порядок спирали против часовой стрелки.
  5. Использует изначальный массив, меняет каждый символ на противположный регистр и выводит переделанный массив.

     Для удобства выполнения задачи, я делаю копию нужного нам массива symbs, называя его symbsdef

|             | Тип                | min значение    | max значение   |
|-------------|--------------------|-----------------|----------------|
| N (Число 1) | Натуральное число | 1  | 10<sup>9</sup> |
| symbs[i][j]  | Символ | A | z |

На вход сначала подается целое число N, то есть integer, так как вводим количество, то N целое положительное, то есть натуральное.
После этого вводятся символы в массив, то есть char, так как в условии сказано "строчные и заглавные буквы латинского алфавита".
Их количество N*N, по N символов на каждую строку.

Выходит:
1. ничего
2. Отсортированный массив символов, исходя из условия 2
3. Символ(ы), которые встречается чаще всего
4. Массив символов в строку по спирали
5. Зашифрованный массив символов
   Значит, всегда будет выводит или символ, или массив символов


### 3. Выбор структуры данных
|  наименование   | Тип          |
|-----|--------------|
| N   | integer      |
| symbs | char [][] |
- число N - integer, размерность матрицы
- symbs - char, так как в матрице хранятся символы


### 4. Алгоритм и математическая модель

На русском языке подробно расписать, что и в каком порядке делает Ваша программа.



### 5. Программа

```java
  import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);


        // Считывание массива
        System.out.println("Введите размер массива N:");
        int N = in.nextInt();
        char[][] symbs = new char[N][N];

        // 1.считывает с консоли размер массива N, затем элементы массива
        // размером N*N.
        System.out.println("Введите элементы массива построчно через пробел, в каждой строке по N элементов:");
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                symbs[i][j] = in.next().charAt(0);
            }
        }




        // Сортировка столбцов по количеству гласных с использованием 3 подпрограмм
        // Переменная k в данном контексте отвечает за текущий индекс столбца,
        // который сравнивается с соседним столбцом в процессе сортировки массива по количеству гласных.
        // Алгоритм основан на пузырьковой сортировке, она сравнивает два соседних столбца с индексами k и k+1
        // и при необходимости меняет их местами, чтобы столбцы с меньшим количеством гласных оказались раньше.


        for (int j = 0; j < symbs.length - 1; j++) {
            for (int k = 0; k < symbs.length - 1 - j; k++) {
                int glas1 = countGlass(symbs, k, N);
                int glas2 = countGlass(symbs, k + 1, N);
                if ((glas1 > glas2) || (glas1 == glas2) && (sumAsc(symbs, k, N) > sumAsc(symbs, k + 1, N))) {  //
                    swapColonn(symbs, k, k + 1, N);
                }
            }
        }


        // 2.выводит измененный массив
        System.out.println("Отсортированный массив:");
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                System.out.print(symbs[i][j] + " ");
            }
            System.out.println();
        }


        // 3. нахождение самого частого элемента (без подрограмм)
        int q = 'z' - 'a' + 1; // удобная переменная для знания количества букв в нижнем регистре
        int[] freq = new int[q]; // Массив для подсчёта частот букв
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                char c = symbs[i][j];
                // Проверяем, является ли символ буквой
                if (c >= 'A' && c <= 'Z') { // Если символ в верхнем регистре
                    c = (char) (c + 'a' - 'A'); // Преобразуем символ в нижний регистр
                }
                if (c >= 'a' && c <= 'z') { // Если символ - буква
                    freq[c - 'a']++; // Увеличиваем соответствующий счётчик
                }
            }
        }

// поиск количества самого частого элемента
        int maxF = 0;
        for (int i = 0; i < freq.length; i++) {
            int FFreq = freq[i];
            if (FFreq > maxF) {
                maxF = FFreq;
            }
        }

// Поиск всех символов с максимальной частотой
        System.out.print("Символ(ы), которые встречаются чаще всего: ");
        for (int i = 0; i < q; i++) {
            if (freq[i] == maxF) {
                System.out.print((char) (i + 'a') + " "); // Преобразуем индекс обратно в символ
            }
        }
        // 4. спираль (это ужас)
        System.out.println("\nЭлементы массива в виде спирали (против часовой стрелки):");

// Начальные координаты для центра
        int x = N / 2;
        int y = N / 2;

// Если N чётное, сдвигаем центр влево и вверх
        if (N % 2 == 0) {
            x--;
            y--;
        }

        System.out.print(symbs[x][y] + " "); // Центральный элемент

// Направления движения: вверх, влево, вниз, вправо
        int[][] orientation = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
        int currentNapravlenie = 0; // Текущее направление движения
        int steps = 1;    // Количество шагов в текущем сегменте
        int count = 1;    // Счётчик пройденных элементов

        // Пока не прошли все элементы массива
        while (count < N * N) {
            // Два сегмента одинаковой длины перед увеличением длины сегмента
            for (int segment = 0; segment < 2; segment++) { // Повторяем дважды для каждого направления (по два сегмента в каждом направлении)
                for (int step = 0; step < steps; step++) { // Для текущего сегмента выполняем 'steps' шагов
                    // Обновляем координаты
                    x += orientation[currentNapravlenie][0];
                    y += orientation[currentNapravlenie][1];

                    // Проверка на выход за пределы массива
                    if (x >= 0 && x < N && y >= 0 && y < N) {
                        System.out.print(symbs[x][y] + " ");
                        count++;
                    }
                }
                // После завершения одного сегмента (например, движения вверх или влево), меняем направление
                currentNapravlenie = (currentNapravlenie + 1) % 4;
            }
            // Увеличиваем количество шагов для следующей пары сегментов
            steps++;
        }

        // 5. зашифрованный массив
        System.out.println("\nЗашифрованный массив:");
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (Character.isUpperCase(symbs[i][j])) { // Если буква заглавная, делаем её строчной
                    symbs[i][j] = Character.toLowerCase(symbs[i][j]);
                } else if (Character.isLowerCase(symbs[i][j])) { // Если буква строчная, делаем её заглавной
                    symbs[i][j] = Character.toUpperCase(symbs[i][j]);
                }
                System.out.print(symbs[i][j] + " "); // Вывод символа
            }
            System.out.println(); // Переход на новую строку после каждого ряда
        }

    }




    // блок подпрограмм
    // делает подсчёт количества гласных в столбце
    public static int countGlass(char[][] symbs, int columm, int stroka) {
        int count = 0;
        for (int i = 0; i < stroka; i++) {
            if (symbs[i][columm] == 'a' || symbs[i][columm] == 'e' || symbs[i][columm] == 'i' || symbs[i][columm] == 'o' || symbs[i][columm] == 'u' ||
                    symbs[i][columm] == 'A' || symbs[i][columm] == 'E' || symbs[i][columm] == 'I' || symbs[i][columm] == 'O' || symbs[i][columm] == 'U') {
                count++;
            }
        }
        return count;
    }

    // подсчёт суммы аски-кодов в столбце
    public static int sumAsc(char[][] symbs, int column, int stroka) {
        int sum = 0;
        for (int i = 0; i < stroka; i++) {
            sum += symbs[i][column];
        }
        return sum;
    }

    // перемещение букв в строках
    public static void swapColonn(char[][] symbs, int column1, int column2, int stroka) {
        for (int i = 0; i < stroka; i++) {
            char temp = symbs[i][column1];
            symbs[i][column1] = symbs[i][column2];
            symbs[i][column2] = temp;
        }
    }
    // конец первого блока подпрограмм
}



```


### 6. Анализ правильности решения

Привести тесты и анализ работы программы для этих тестов.
Очень неплохо было бы обосновать выбор тестов.

1. Тест на что-то

- Input:
```
Введите размер массива N:
3
Введите элементы массива построчно через пробел, в каждой строке по N элементов:
a b c
b a c
c b a
```

- Output:
```
Отсортированный массив:
b a c 
a b c 
b c a 
Символ(ы), которые встречаются чаще всего: a b c 
Элементы массива в виде спирали (против часовой стрелки):
b a b a b c a c c 
Зашифрованный массив:
B A C 
A B C 
B C A  
```

2. Тест на что-то еще

- Input:
    ```
    1
    -1
    ```

- Output:
    ```
    0
    ```






