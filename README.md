
## Отчет по лабораторной работе №2

#### № группы: `ПМ-2402`

#### Выполнил: `Грашин Илья Романович`

#### Вариант: `7`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм и математическая модель](#4-алгоритм-и-математическая-модель)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

 Напишите программу на Java, которая выполняет следующие действия с
 двумерным массивом символов (строчные и заглавные буквы латинского
 алфавита):
 1. Считывает с консоли размер массива N , затем элементы массива
 размером N×N.
 2. Сортирует столбцы массива в порядке возрастания количества гласных букв в каждом столбце.
 При этом внутри столбца символы остаются на своих местах.
 Если показатели равны, сортирует столбцы по сумме ASCII-кодов символов.
 3. Находит и выводит символ, который чаще всего встречается в массиве (без учёта регистра).
 Если таких символов несколько, выводит
 все.
 4. Выводит элементы массива в виде спирали,
 начиная с центрального элемента и двигаясь против часовой стрелки.
 Реализовать алгоритм без использования дополнительных массивов.
 5. Шифрует массив, изменяя регистр букв на противоположный, вы
 водит зашифрованный массив


### 2. Входные и выходные данные

  1. На вход подается размер массива (N), после этого вводится NxN элементов в виде квадрата.
  2. Программа анализираует весь массив символов и определяет гласные буквы, после этого сортирует построчно массив, передвигая гласные буквы в конец, а после этого так же каждую строку сортирует по ASCII - кодам.
  3. Опять анализирует массив и находит самый частый символ (без учета регистра) и выводит его, если таких символов несколько, то выводит их в алфавитном порядке.
  4. Использует массив, находит цетральный элемент, и, начиная с него, выводит массив в строку, используя порядок спирали против часовой стрелки.
  5. Использует  массив, меняет каждый символ на противположный регистр и выводит переделанный массив.

     Для удобства выполнения задачи, я делаю копию нужного нам массива symbs, называя его symbsdef

|             | Тип                | min значение    | max значение   |
|-------------|--------------------|-----------------|----------------|
| N | Натуральное число | 1  | 10<sup>9</sup> |
| symbs[i][j]  | Символ | A | z |

На вход сначала подается целое число N, то есть integer, так как вводим количество, то N целое положительное, то есть натуральное.
После этого вводятся символы в массив, то есть char, так как в условии сказано "строчные и заглавные буквы латинского алфавита".
Их количество N*N, по N символов на каждую строку.

Выходит:
1. ничего
2. Отсортированный массив символов, исходя из условия 2
3. Символ(ы), которые встречается чаще всего
4. Массив символов в строку по спирали
5. Зашифрованный массив символов
   Значит, всегда будет выводит или символ, или массив символов


### 3. Выбор структуры данных
|  наименование   | Тип          |
|-----|--------------|
| N   | integer      |
| symbs | char [][] |
- число N - integer, размерность матрицы
- symbs - char, так как в матрице хранятся символы


### 4. Алгоритм и математическая модель

1.1.0 На вход подается натуральное число N, которое обозначает кол-во строк и элементов в строке. Далее по этим параметрам вводятся символы латинского алфавита, программа считывает и запоминает их.

2.1.0 Первой задачей была сортировка массива по количеству гласных букв в столбце, а далее дополнительная сортировка по ASCII-кодам:
2.1.1 Первая подпрограмма countGlass считает количество глассных букв (проверкой каждого символа) в целом по массиву и отдельно в каждом столбце.
2.1.2 Вторая подпрограмма sunAsc считает сумму ASCII-кодов в каждом столбце.
2.1.3 Третья подпрограмма swapColonn производит смену символа по столбцам путем попарного перемещения символов внутри строк и столбцов.
2.2.1 В программу подставляются значения из массива и исходя из подпрограмм проверяется выполнения условий количества глассных букв в столбце или сумму ASCII-кодов.
2.2.2 После проверки всех условий и выполнения перестановок выводит отсортированный массив.      

3.1.0 Необходимо найти самый частый элемент массива.
3.1.1 Программа пробегается по массиву, преобразует буквы верхнего регистра в нижний и считает количество каждого элемента в массиве. 
3.1.2 Далее запоминает их индексы, после этого сравнивает максимальные значения количества символа.
3.1.3 Выводит самые частые символы в алфавитном порядке по запомненным индексам один раз на символ.

4.1.0 Необходимо вывести массив в определенном порядке в строчку, этот порядок - спираль против часовой стрелки, начиная с центрального элемента
4.1.1 Было принятно решение (если N четное) сделать из центрального квадрата 2х2 правый нижний элемент, так как при движении против часовой стрелки первые два шага будут вверх и влево,
что далее дает более понятное расположение элементов, так как это поможет как можно меньше переходить за границы массива и перескакивать. А если же N нечетное, то центр и будет цетральным элементом, там сложностей не возникнет.
Выводим цетральный элемент.
4.1.2 Задаем направления движения в массиве через определение ориентации для будущего передвижения с вызовом элемента этого массива. 
4.1.3 Создаем счетчик для того, чтобы при прохождении всех элементов у нас заканчивался цикл. При одном шаге прибавляем к счетчику 1
4.1.4 Создаем счетчик шагов, для уже одного сегмента прохода, он должен быть меньше общего количества шагов.
4.1.5 Выполняем вывод элементов массива циклично исходя из их выбора по циклу, то есть при конструкции 
a b c
t i o     у нас после буквы i шло поднятие вверх, счетчик увеличивался на 1, далее идет элемент b, так как в цикле следующий шаг влево, то выполняется изменение ориентации и выводится элемент с нужным индексом, то есть a и так далее
j k l     в конце концов у нас будет i b a t j k l o c
4.1.6 Так как у нас происходит деление на сегменты, то после прохождения всего сегмента (а это значит 4 шага:вверх, влево, вниз, вправо) у нас к этой переменной добавляется один и находится остаток от деления на 4
Это сделано для того, чтобы эта переменная не стала больше 4, иначе программа не будет выполняться
4.1.7 Вывод в виде спирали

5.1.0 Необходимо изменить в массиве у символов верхний регистр на нижний и наоборот.
5.1.1 Программа пробегает по каждой букве массива и если видит, что она в верхнем регистре, то изменяет на нижний и наоборот. Это выполнено с помощью функций Character.toLowerCase и Character.toUpperCase.
5.1.2 Выводит зашифрованный массив

### 5. Программа

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // Считывание массива
        System.out.println("Введите размер массива N:");
        int N = in.nextInt();
        char[][] symbs = new char[N][N];
        // 1.считывает с консоли размер массива N, затем элементы массива
        // размером N*N.
        System.out.println("Введите элементы массива построчно через пробел, в каждой строке по N элементов:");
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                symbs[i][j] = in.next().charAt(0);
            }
        }
        // Сортировка столбцов по количеству гласных с использованием 3 подпрограмм
        // Переменная k в данном контексте отвечает за текущий индекс столбца,
        // который сравнивается с соседним столбцом в процессе сортировки массива по количеству гласных.
        // Алгоритм основан на пузырьковой сортировке, она сравнивает два соседних столбца с индексами k и k+1
        // и при необходимости меняет их местами, чтобы столбцы с меньшим количеством гласных оказались раньше.
        for (int j = 0; j < symbs.length - 1; j++) {
            for (int k = 0; k < symbs.length - 1 - j; k++) {
                int glas1 = countGlass(symbs, k, N);
                int glas2 = countGlass(symbs, k + 1, N);
                if ((glas1 > glas2) || (glas1 == glas2) && (sumAsc(symbs, k, N) > sumAsc(symbs, k + 1, N))) {
                    // если гласных букв в предыдущем столбце больше или же их одинаковое количество, но сумма ascii больше, чем в последующем, то происходит замена гласных
                    swapColonn(symbs, k, k + 1, N);
                }
            }
        }
        // 2.выводит измененный массив
        System.out.println("Отсортированный массив:");
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                System.out.print(symbs[i][j] + " ");
            }
            System.out.println();
        }
        // 3. нахождение самого частого элемента (без подрограмм)
        int q = 'z' - 'a' + 1; // удобная переменная для знания количества букв в нижнем регистре
        int[] freq = new int[q]; // Массив для подсчёта частот букв
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                char c = symbs[i][j];
                // Проверяем, является ли символ буквой верхнего или нижнего регистра
                if (c >= 'A' && c <= 'Z') { // Если символ в верхнем регистре
                    c = (char) (c + 'a' - 'A'); // Преобразуем символ в нижний регистр
                }
                if (c >= 'a' && c <= 'z') { // Если символ - буква нижнего регистра
                    freq[c - 'a']++; // Увеличиваем соответствующий счётчик
                }
            }
        }
// поиск количества самого частого элемента
        int maxF = 0; // переменная, обозначающая счетчик, который считает количество каждого элемента и затем отбирает лишь наибольший
        for (int i = 0; i < freq.length; i++) {
            int FFreq = freq[i];
            if (FFreq > maxF) {
                maxF = FFreq;
            }
        }
// Поиск всех символов с максимальной частотой
        System.out.print("Символ(ы), которые встречаются чаще всего: ");
        for (int i = 0; i < q; i++) {
            if (freq[i] == maxF) {
                System.out.print((char) (i + 'a') + " "); // Преобразуем индекс обратно в символ
            }
        }


        // 4. спираль (это ужас)
        System.out.println("\nЭлементы массива в виде спирали (против часовой стрелки):");
            // Начальные координаты для центра
        int x = N / 2;
        int y = N / 2;
        System.out.print(symbs[x][y] + " "); // Центральный элемент
             // Направления движения: вверх, влево, вниз, вправо
        int[][] Napravlenie = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
        int currentNapravlenie = 0; // Текущее направление движения
        int steps = 1;    // Количество шагов в текущем сегменте
        int count = 1;    // Счётчик пройденных элементов
             // Пока не прошли все элементы массива
        while (count < N * N) {
            // Два сегмента одинаковой длины перед увеличением длины сегмента
            for (int segment = 0; segment < 2; segment++) { // Повторяем дважды для каждого направления (по два сегмента в каждом направлении)
                for (int step = 0; step < steps; step++) { // Для текущего сегмента выполняем 'steps' шагов
                    // Обновляем координаты
                    x += Napravlenie[currentNapravlenie][0];
                    y += Napravlenie[currentNapravlenie][1];

                    // Проверка на выход за пределы массива
                    if (x >= 0 && x < N && y >= 0 && y < N) {
                        System.out.print(symbs[x][y] + " ");
                        count++;
                    }
                }
                // После завершения одного сегмента (например, движения вверх или влево), меняем направление
                // так как у нас 4 направления, то после прохождения всех, то мы прибавляем к текущему направлению один и находим остаток от деления на 4
                currentNapravlenie = (currentNapravlenie + 1) % 4;
            }
            // Увеличиваем количество шагов для следующей пары сегментов
            steps++;
        }
        // 5. зашифрованный массив
        System.out.println("\nЗашифрованный массив:");
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (Character.isUpperCase(symbs[i][j])) { // Если буква заглавная, делаем её строчной
                    symbs[i][j] = Character.toLowerCase(symbs[i][j]);
                } else if (Character.isLowerCase(symbs[i][j])) { // Если буква строчная, делаем её заглавной
                    symbs[i][j] = Character.toUpperCase(symbs[i][j]);
                }
                System.out.print(symbs[i][j] + " "); // Вывод символа
            }
            System.out.println(); // Переход на новую строку после каждого ряда
        }
    }
    // блок подпрограмм
    // делает подсчёт количества гласных в столбце
    public static int countGlass(char[][] symbs, int columm, int stroka) {
        int count = 0; // для подсчета всех гласных
        for (int i = 0; i < stroka; i++) {
            if (symbs[i][columm] == 'a' || symbs[i][columm] == 'e' || symbs[i][columm] == 'i' || symbs[i][columm] == 'o' || symbs[i][columm] == 'u' ||
                    symbs[i][columm] == 'A' || symbs[i][columm] == 'E' || symbs[i][columm] == 'I' || symbs[i][columm] == 'O' || symbs[i][columm] == 'U') {
                count++; // если символ гласная, то счетчик + 1
            }
        }
        return count;
    }

    // подсчёт суммы аски-кодов в столбце
    public static int sumAsc(char[][] symbs, int column, int stroka) {
        int sum = 0;
        for (int i = 0; i < stroka; i++) {
            sum += symbs[i][column];   //считает сумму ascii
        }
        return sum;
    }

    // перемещение букв в строках
    public static void swapColonn(char[][] symbs, int column1, int column2, int stroka) {
        for (int i = 0; i < stroka; i++) {
            char temp = symbs[i][column1];
            symbs[i][column1] = symbs[i][column2];
            symbs[i][column2] = temp;
        }
    }

    // конец первого блока подпрограмм
}
```


### 6. Анализ правильности решения

Привести тесты и анализ работы программы для этих тестов.
Очень неплохо было бы обосновать выбор тестов.

1. Тест на что-то

- Input:
```
Введите размер массива N:
3
Введите элементы массива построчно через пробел, в каждой строке по N элементов:
a b c
b a c
c b a
```

- Output:
```
Отсортированный массив:
b a c 
a b c 
b c a 
Символ(ы), которые встречаются чаще всего: a b c 
Элементы массива в виде спирали (против часовой стрелки):
b a b a b c a c c 
Зашифрованный массив:
B A C 
A B C 
B C A   
```

2. Тест на что-то еще

- Input:
    ```
    1
    -1
    ```

- Output:
    ```
    0
    ```






